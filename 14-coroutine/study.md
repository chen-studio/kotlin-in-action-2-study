## 0.Objectives
- 동시성과 병렬성의 개념에 대한 이해
- 코틀린에서 동시성 연산을 만드는 빌딩 블록, suspend 함수
- 코틀린에서 코루틴을 활용해 동시성 프로그래밍에 접근하는 방법

## 1. 동시성(Concurrency) vs 병렬성(Parallelism)
- 동시성: 여러 작업을 동시에 실행하는것을 의미하지만 모든 작업을 함께 실행하는 것은 아님
- n개의 작업의 일부분을 번갈아가면서 하나의 작업자가 수행하는 것도 동시성
- 즉, 코트를 여러 부분으로 나눠서 동시에 수행할 수 있는 능력을 의미
- 병렬성: 여러 작업을 동시에 실행하지만 실제로 물리적으로 동시에 실행하는 것을 의미

## 2. 코틀린의 동시성 처리 방법: 일시 중단 함수와 코루틴
- 코루틴은 코틀린의 가장 강력한 특징으로, 비동기적으로 실행되는 넌블로킹 동시성 코드를 우아하게 작성할 수 있게 해준다
- 스레드와 같은 전통적인 방식보다 훨씬 가볍게 동작한다
- 구조화된 동시성을 통해 동시성 작업과 그 생명주기를 관리할 수 있는 기능도 제공한다
- 먼저 스레드와 코루틴을 비교해본다

## 3. 스레드와 코루틴의 비교
- JVM에서 병렬 프로그래밍과 동시성 프로그래밍을 위한 고전적인 추상화는 스레드를 사용하는 것이다
- 스레드는 서로 독립적으로 동시에 실행되는 코드 블록을 지정할 수 있게 해준다
- 스레드도 코틀린에서 자바와 100% 호환된다
- 아래는 코틀린에서 스레드를 수행하는 예시를 보여준다
```.kt
import kotlin.concurrent.thread

fun main() {
  println("I'm on ${Thread.currentThread().name}")
  thread {
    println("And I'm on ${Thread.currentThread().name}")
  }
}
```
- 하지만 시스템 스레드를 생성하고 관리하는 것은 비용이 많이 든다
- 최신 시스템이더라도 한 번에 몇 천개의 스레드만 효과적으로 관리할 수 있다
- 어쨌든 스레드 관리의 비용이 많이 든다는 내용 설명
- 게다가 스레드가 네트워크 요청 등이 완료되기를 기다리는 동안에는 블록되며 그 동안에 해당 스레드는 아무런 작업을 할 수 없다
- 따라서 새 스레드를 생성할 떄는 매우 신중해야 하며 짧은 시간 동안 잠깐 사용하는 것은 피하는 것이 좋다
- 스레드는 기본적으로 독립적인 프로세스로 존재하기 때문에 작업을 관리하고 조정하는 데 어려움이 있을 수 있다
- 특히 취소나 예외 처리 같은 처리가 어렵기 떄문에 많은 제약이 존재한다

### 코틀린의 대안: 코루틴
- 코틀린에서 스레드의 대안으로 도입한 코루틴이라는 추상화의 장점에 대해 먼저 알아본다
- 코루틴은 초경량 추상화이며 일반적인 노트북에서도 100,000개 이상의 코루틴을 쉽게 실행할 수 있다
- 또한 코루틴은 생성하고 관리하는 비용이 저렴하다. 이는 훨씬 세밀한 작업이나 아주 짧은 시간 동안만 실행하는 작업에도 더 넓게 활용할 수 있다는 의미이다
- 코루틴은 시스템 자원을 블록시키지 않고 실행을 일시 
